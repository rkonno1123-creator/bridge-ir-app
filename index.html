<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>æ©‹æ¢èµ¤å¤–ç·šè§£æã‚·ã‚¹ãƒ†ãƒ </title>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-storage-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { 
      font-family: 'Meiryo UI', -apple-system, BlinkMacSystemFont, sans-serif; 
      background: #1a1a2e; 
      color: #eee; 
      height: 100vh;
      overflow: hidden;
    }
    
    /* ãƒ˜ãƒƒãƒ€ãƒ¼ */
    .header {
      background: #16213e;
      padding: 12px 20px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid #00d4ff33;
    }
    .header h1 {
      font-size: 1.2rem;
      color: #00d4ff;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .drawing-tabs {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .drawing-tab {
      padding: 8px 16px;
      background: #0a0a15;
      border: 1px solid #333;
      border-radius: 6px;
      color: #aaa;
      cursor: pointer;
      font-size: 0.85rem;
      transition: all 0.2s;
    }
    .drawing-tab:hover { border-color: #00d4ff; color: #fff; }
    .drawing-tab.active { background: #00d4ff; color: #000; border-color: #00d4ff; }
    .drawing-tab.add { background: #27ae60; color: #fff; border-color: #27ae60; }
    .delete-drawing { 
      margin-left: 6px; 
      color: #ff6b6b; 
      cursor: pointer;
      font-weight: bold;
    }
    .delete-drawing:hover { color: #ff0000; }
    
    /* ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ */
    .main-container {
      display: flex;
      height: calc(100vh - 60px);
    }
    
    /* å›³é¢ã‚¨ãƒªã‚¢ */
    .drawing-area {
      flex: 1;
      position: relative;
      overflow: auto;
      background: #0a0a15;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .drawing-wrapper {
      position: relative;
      display: inline-block;
    }
    .drawing-image {
      max-width: 100%;
      max-height: calc(100vh - 80px);
      display: block;
    }
    .empty-state {
      color: #444;
      font-size: 1rem;
      text-align: center;
    }
    .instructions {
      position: absolute;
      bottom: 15px;
      left: 15px;
      background: rgba(0,0,0,0.7);
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 0.75rem;
      color: #888;
    }
    .edit-mode-btn {
      position: absolute;
      bottom: 15px;
      right: 15px;
      background: rgba(0,0,0,0.7);
      border: 1px solid #444;
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 0.85rem;
      color: #aaa;
      cursor: pointer;
      transition: all 0.2s;
    }
    .edit-mode-btn:hover {
      border-color: #00d4ff;
      color: #fff;
    }
    .edit-mode-btn.active {
      background: #00d4ff;
      color: #000;
      border-color: #00d4ff;
    }
    
    /* ãƒ”ãƒ³ */
    .pin {
      position: absolute;
      width: 24px;
      height: 24px;
      border-radius: 50% 50% 50% 0;
      transform: translate(-50%, -100%) rotate(-45deg);
      cursor: pointer;
      border: 2px solid #fff;
      box-shadow: 0 2px 8px rgba(0,0,0,0.5);
      transition: transform 0.15s;
      z-index: 10;
    }
    .pin:hover {
      transform: translate(-50%, -100%) rotate(-45deg) scale(1.2);
      z-index: 20;
    }
    .pin.selected {
      transform: translate(-50%, -100%) rotate(-45deg) scale(1.3);
      z-index: 30;
      box-shadow: 0 0 15px rgba(0, 212, 255, 0.8);
    }
    .pin.healthy { background: #27ae60; }
    .pin.observe { background: #f39c12; }
    .pin.floating { background: #e74c3c; }
    .pin.unanalyzed { background: #666; }
    .pin-number {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) rotate(45deg);
      font-size: 10px;
      font-weight: bold;
      color: #fff;
      white-space: nowrap;
    }
    
    /* è©³ç´°ãƒ‘ãƒãƒ« */
    .detail-panel {
      width: 450px;
      background: #16213e;
      border-left: 1px solid #00d4ff33;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .detail-panel.collapsed { width: 0; border: none; }
    
    .panel-header {
      padding: 15px;
      border-bottom: 1px solid #00d4ff33;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .panel-header h2 {
      font-size: 1rem;
      color: #00d4ff;
    }
    .close-panel {
      background: none;
      border: none;
      color: #666;
      font-size: 1.5rem;
      cursor: pointer;
    }
    .close-panel:hover { color: #fff; }
    
    /* ã‚¿ãƒ– */
    .tabs {
      display: flex;
      border-bottom: 1px solid #333;
    }
    .tab {
      flex: 1;
      padding: 12px 8px;
      background: none;
      border: none;
      color: #666;
      cursor: pointer;
      font-size: 0.8rem;
      transition: all 0.2s;
    }
    .tab:hover { color: #aaa; }
    .tab.active { 
      color: #00d4ff; 
      border-bottom: 2px solid #00d4ff;
      background: rgba(0, 212, 255, 0.1);
    }
    
    /* ã‚¿ãƒ–ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ */
    .tab-content {
      flex: 1;
      overflow-y: auto;
      padding: 15px;
    }
    .tab-pane { display: none; }
    .tab-pane.active { display: block; }
    
    /* ç”»åƒè¡¨ç¤º */
    .image-display {
      background: #0a0a15;
      border-radius: 8px;
      padding: 10px;
      margin-bottom: 15px;
      text-align: center;
    }
    .image-display img {
      max-width: 100%;
      max-height: 250px;
      border-radius: 4px;
    }
    .image-display .no-image {
      color: #444;
      padding: 40px;
    }
    .image-filename {
      font-size: 0.75rem;
      color: #666;
      margin-top: 8px;
    }
    
    /* ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ */
    .upload-area {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .upload-btn {
      flex: 1;
      min-width: 120px;
      padding: 10px;
      background: #0a0a15;
      border: 1px dashed #444;
      border-radius: 6px;
      color: #888;
      cursor: pointer;
      font-size: 0.8rem;
      transition: all 0.2s;
    }
    .upload-btn:hover {
      border-color: #00d4ff;
      color: #00d4ff;
    }
    input[type="file"] { display: none; }
    
    /* ãƒ•ã‚©ãƒ¼ãƒ  */
    .form-group {
      margin-bottom: 15px;
    }
    .form-group label {
      display: block;
      font-size: 0.8rem;
      color: #888;
      margin-bottom: 5px;
    }
    .form-group input,
    .form-group select,
    .form-group textarea {
      width: 100%;
      padding: 10px;
      background: #0a0a15;
      border: 1px solid #333;
      border-radius: 6px;
      color: #eee;
      font-size: 0.9rem;
    }
    .form-group textarea {
      min-height: 100px;
      resize: vertical;
    }
    .form-group select { cursor: pointer; }
    
    /* åˆ¤å®šã‚¹ã‚¿ã‚¤ãƒ« */
    select.judgment-healthy { background: #1a3d1a; border-color: #27ae60; }
    select.judgment-observe { background: #3d3d1a; border-color: #f39c12; }
    select.judgment-floating { background: #3d1a1a; border-color: #e74c3c; }
    
    /* GSDè¡¨ç¤º */
    .gsd-display {
      background: #0a0a15;
      padding: 10px;
      border-radius: 6px;
      font-size: 0.85rem;
      margin-bottom: 15px;
    }
    .gsd-display strong { color: #00d4ff; }
    
    /* ãƒœã‚¿ãƒ³ */
    .btn {
      padding: 12px 20px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.2s;
    }
    .btn-primary { background: #00d4ff; color: #000; }
    .btn-primary:hover { background: #00a8cc; }
    .btn-danger { background: #e74c3c; color: #fff; }
    .btn-danger:hover { background: #c0392b; }
    .btn-success { background: #27ae60; color: #fff; }
    .btn-success:hover { background: #1e8449; }
    .btn-export {
      width: 100%;
      padding: 15px;
      background: #00cc66;
      color: #fff;
      font-size: 1rem;
      font-weight: bold;
      margin-top: 15px;
    }
    .btn-export:hover { background: #00aa55; }
    
    .btn-group {
      display: flex;
      gap: 10px;
      margin-top: 15px;
    }
    .btn-group .btn { flex: 1; }
    
    /* ç¯„å›²é¸æŠã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ */
    .image-with-overlay {
      position: relative;
      display: inline-block;
      cursor: crosshair;
    }
    .image-with-overlay img {
      max-width: 100%;
      max-height: 250px;
      border-radius: 4px;
      user-select: none;
      -webkit-user-drag: none;
    }
    .area-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    .thermal-area-controls {
      display: flex;
      gap: 10px;
      margin: 10px 0;
    }
    .btn-secondary {
      background: #444;
      color: #fff;
    }
    .btn-secondary:hover {
      background: #555;
    }
    .btn-warning {
      background: #e67e22;
      color: #fff;
    }
    .btn-warning:hover {
      background: #d35400;
    }
    
    /* ãƒˆãƒªãƒŸãƒ³ã‚°ãƒªã‚¹ãƒˆ */
    .crop-list {
      margin-top: 15px;
    }
    .crop-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px;
      background: #0a0a15;
      border-radius: 6px;
      margin-bottom: 8px;
    }
    .crop-item img {
      width: 60px;
      height: 45px;
      object-fit: cover;
      border-radius: 4px;
    }
    .crop-item span { flex: 1; font-size: 0.8rem; }
    .crop-item button {
      background: #c00;
      border: none;
      color: #fff;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.75rem;
    }
    
    /* ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚° */
    .loading {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: #1a1a2e;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    .loading-spinner {
      width: 50px;
      height: 50px;
      border: 3px solid #333;
      border-top-color: #00d4ff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ– */
    @media (max-width: 900px) {
      .main-container { flex-direction: column; }
      .detail-panel { 
        width: 100%; 
        height: 50vh;
        border-left: none;
        border-top: 1px solid #00d4ff33;
      }
    }
  </style>
</head>
<body>
  <div id="app">
    <div style="display:flex;align-items:center;justify-content:center;height:100vh;background:#1a1a2e;color:#00d4ff;">
      èª­ã¿è¾¼ã¿ä¸­...
    </div>
  </div>

  <script>
    // Firebaseèª­ã¿è¾¼ã¿ã‚’å¾…ã¤
    function waitForFirebase(callback) {
      if (typeof firebase !== 'undefined') {
        callback();
      } else {
        setTimeout(() => waitForFirebase(callback), 100);
      }
    }

    waitForFirebase(function() {
    // Firebaseè¨­å®š
    const firebaseConfig = {
      apiKey: "AIzaSyAiJ-c45y9PE5wfCKFUFunTEqwFRsE5_1I",
      authDomain: "infrared-cameramera.firebaseapp.com",
      projectId: "infrared-cameramera",
      storageBucket: "infrared-cameramera.firebasestorage.app",
      messagingSenderId: "475644542906",
      appId: "1:475644542906:web:d26d9df6bc0c5a1fe6e783"
    };

    // FirebaseåˆæœŸåŒ–
    if (!firebase.apps.length) {
      firebase.initializeApp(firebaseConfig);
    }
    const storage = firebase.storage();
    const db = firebase.firestore();

    // ã‚¢ãƒ—ãƒªçŠ¶æ…‹
    const state = {
      loading: true,
      drawings: [],
      currentDrawingId: null,
      pins: [],
      selectedPinId: null,
      activeTab: 'visible',
      distance: 8,
      draggingPin: null,
      editMode: false,
      isDrawingArea: false,
      tempArea: null
    };

    // DOMè¦ç´ å–å¾—
    const app = document.getElementById('app');

    // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
    function render() {
      const currentDrawing = state.drawings.find(d => d.id === state.currentDrawingId);
      const currentPins = state.pins.filter(p => p.drawingId === state.currentDrawingId);
      const selectedPin = state.pins.find(p => p.id === state.selectedPinId);

      if (state.loading) {
        app.innerHTML = `
          <div class="loading">
            <div class="loading-spinner"></div>
          </div>
        `;
        return;
      }

      app.innerHTML = `
        <div class="header">
          <h1>ğŸ”¥ æ©‹æ¢èµ¤å¤–ç·šè§£æã‚·ã‚¹ãƒ†ãƒ </h1>
          <div class="drawing-tabs">
            ${state.drawings.map(d => `
              <div class="drawing-tab ${d.id === state.currentDrawingId ? 'active' : ''}" 
                   onclick="switchDrawing('${d.id}')">
                ${d.name}
                <span class="delete-drawing" onclick="event.stopPropagation(); deleteDrawing('${d.id}')">Ã—</span>
              </div>
            `).join('')}
            <div class="drawing-tab add" onclick="addDrawing()">ï¼‹ å›³é¢è¿½åŠ </div>
          </div>
        </div>
        
        <div class="main-container">
          <div class="drawing-area" onclick="handleDrawingClick(event)" 
               onmousemove="handlePinDrag(event)" onmouseup="handlePinDragEnd(event)"
               ontouchmove="handleTouchDrag(event)" ontouchend="handlePinDragEnd(event)">
            ${currentDrawing ? `
              <div class="drawing-wrapper" id="drawingWrapper">
                <img src="${currentDrawing.url}" class="drawing-image" id="drawingImage" draggable="false">
                ${currentPins.map((pin, i) => `
                  <div class="pin ${pin.judgment || 'unanalyzed'} ${pin.id === state.selectedPinId ? 'selected' : ''}"
                       style="left: ${pin.x}%; top: ${pin.y}%; cursor: ${state.editMode ? 'move' : 'pointer'};"
                       onmousedown="handlePinMouseDown(event, '${pin.id}')"
                       ontouchstart="handlePinTouchStart(event, '${pin.id}')">
                    <span class="pin-number">${(pin.name || String(i + 1)).slice(-3)}</span>
                  </div>
                `).join('')}
              </div>
              <div class="instructions" onclick="event.stopPropagation()">
                ğŸ’¡ ã‚¯ãƒªãƒƒã‚¯ã§ãƒ”ãƒ³è¿½åŠ  | ãƒ”ãƒ³ã‚¯ãƒªãƒƒã‚¯ã§è©³ç´°
              </div>
              <button class="edit-mode-btn ${state.editMode ? 'active' : ''}" onclick="event.stopPropagation(); toggleEditMode()">
                ${state.editMode ? 'âœ… ä½ç½®èª¿æ•´ä¸­' : 'ğŸ“ ãƒ”ãƒ³ä½ç½®èª¿æ•´'}
              </button>
            ` : `
              <div class="empty-state">
                å›³é¢ã‚’è¿½åŠ ã—ã¦ãã ã•ã„
              </div>
            `}
          </div>
          
          ${selectedPin ? `
            <div class="detail-panel">
              <div class="panel-header">
                <h2>ğŸ“ ${selectedPin.name || 'ãƒ”ãƒ³ ' + (currentPins.findIndex(p => p.id === selectedPin.id) + 1)}</h2>
                <button class="close-panel" onclick="closePanel()">Ã—</button>
              </div>
              
              <div class="tabs">
                <button class="tab ${state.activeTab === 'visible' ? 'active' : ''}" onclick="setTab('visible')">å¯è¦–</button>
                <button class="tab ${state.activeTab === 'infrared' ? 'active' : ''}" onclick="setTab('infrared')">èµ¤å¤–ç·š</button>
                <button class="tab ${state.activeTab === 'color8' ? 'active' : ''}" onclick="setTab('color8')">8è‰²</button>
                <button class="tab ${state.activeTab === 'analysis' ? 'active' : ''}" onclick="setTab('analysis')">è§£æ</button>
              </div>
              
              <div class="tab-content">
                <!-- å¯è¦–ç”»åƒã‚¿ãƒ– -->
                <div class="tab-pane ${state.activeTab === 'visible' ? 'active' : ''}">
                  <div class="image-display">
                    ${selectedPin.images?.visible ? `
                      <div class="image-with-overlay" 
                           onmousedown="handleAreaMouseDown(event)"
                           onmousemove="handleAreaMouseMove(event)"
                           onmouseup="handleAreaMouseUp(event)"
                           ontouchstart="handleAreaTouchStart(event)"
                           ontouchmove="handleAreaTouchMove(event)"
                           ontouchend="handleAreaMouseUp(event)">
                        <img src="${selectedPin.images.visible.url}" alt="å¯è¦–ç”»åƒ" id="visibleImage" draggable="false">
                        <svg class="area-overlay">
                          ${selectedPin.thermalArea ? `
                            <rect
                              x="${Math.min(selectedPin.thermalArea.startX, selectedPin.thermalArea.endX)}%"
                              y="${Math.min(selectedPin.thermalArea.startY, selectedPin.thermalArea.endY)}%"
                              width="${Math.abs(selectedPin.thermalArea.endX - selectedPin.thermalArea.startX)}%"
                              height="${Math.abs(selectedPin.thermalArea.endY - selectedPin.thermalArea.startY)}%"
                              fill="rgba(255, 0, 0, 0.2)"
                              stroke="#ff0000"
                              stroke-width="3"
                            />
                            <text
                              x="${Math.min(selectedPin.thermalArea.startX, selectedPin.thermalArea.endX)}%"
                              y="${Math.max(0, Math.min(selectedPin.thermalArea.startY, selectedPin.thermalArea.endY) - 1)}%"
                              fill="#ff0000"
                              font-size="12"
                              font-weight="bold"
                            >IR SCAN AREA</text>
                          ` : ''}
                          ${state.tempArea ? `
                            <rect
                              x="${Math.min(state.tempArea.startX, state.tempArea.endX)}%"
                              y="${Math.min(state.tempArea.startY, state.tempArea.endY)}%"
                              width="${Math.abs(state.tempArea.endX - state.tempArea.startX)}%"
                              height="${Math.abs(state.tempArea.endY - state.tempArea.startY)}%"
                              fill="rgba(255, 0, 0, 0.15)"
                              stroke="#ff0000"
                              stroke-width="2"
                              stroke-dasharray="5,5"
                            />
                          ` : ''}
                        </svg>
                      </div>
                      <div class="image-filename">${selectedPin.images.visible.filename}</div>
                    ` : `<div class="no-image">ç”»åƒãªã—</div>`}
                  </div>
                  <div class="thermal-area-controls">
                    <button class="btn ${state.isDrawingArea ? 'btn-warning' : 'btn-secondary'}" onclick="toggleDrawingArea()">
                      ${state.isDrawingArea ? 'âœï¸ æç”»ä¸­...' : 'ğŸ“ IRç¯„å›²ã‚’æç”»'}
                    </button>
                    ${selectedPin.thermalArea ? `
                      <button class="btn btn-danger" onclick="deleteThermalArea()">ğŸ—‘ï¸ ç¯„å›²å‰Šé™¤</button>
                    ` : ''}
                  </div>
                  <div class="upload-area">
                    <label class="upload-btn">
                      ğŸ“· å¯è¦–ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
                      <input type="file" accept="image/*" onchange="uploadImage('visible', this.files[0])">
                    </label>
                    <label class="upload-btn" style="background:#9b59b6; border-color:#9b59b6;">
                      ğŸ¯ è¤‡æ•°ç”»åƒã‚’è‡ªå‹•æŒ¯ã‚Šåˆ†ã‘
                      <input type="file" accept="image/*" multiple onchange="uploadMultipleImages(this.files)">
                    </label>
                  </div>
                </div>
                
                <!-- èµ¤å¤–ç·šç”»åƒã‚¿ãƒ– -->
                <div class="tab-pane ${state.activeTab === 'infrared' ? 'active' : ''}">
                  <div class="image-display">
                    ${selectedPin.images?.infrared ? `
                      <img src="${selectedPin.images.infrared.url}" alt="èµ¤å¤–ç·šç”»åƒ">
                      <div class="image-filename">${selectedPin.images.infrared.filename}</div>
                    ` : `<div class="no-image">ç”»åƒãªã—</div>`}
                  </div>
                  <div class="upload-area">
                    <label class="upload-btn">
                      ğŸ”¥ èµ¤å¤–ç·šç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
                      <input type="file" accept="image/*" onchange="uploadImage('infrared', this.files[0])">
                    </label>
                  </div>
                </div>
                
                <!-- 8è‰²ç”»åƒã‚¿ãƒ– -->
                <div class="tab-pane ${state.activeTab === 'color8' ? 'active' : ''}">
                  <div class="image-display">
                    ${selectedPin.images?.color8 ? `
                      <img src="${selectedPin.images.color8.url}" alt="8è‰²ç”»åƒ">
                      <div class="image-filename">${selectedPin.images.color8.filename}</div>
                    ` : `<div class="no-image">ç”»åƒãªã—</div>`}
                  </div>
                  <div class="upload-area">
                    <label class="upload-btn">
                      ğŸ¨ 8è‰²ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
                      <input type="file" accept="image/*" onchange="uploadImage('color8', this.files[0])">
                    </label>
                  </div>
                </div>
                
                <!-- è§£æã‚¿ãƒ– -->
                <div class="tab-pane ${state.activeTab === 'analysis' ? 'active' : ''}">
                  <div class="form-group">
                    <label>ãƒ”ãƒ³å / å†™çœŸç•ªå·</label>
                    <input type="text" id="pinName" value="${selectedPin.name || ''}" 
                           placeholder="ä¾‹: T00484" onchange="updatePinName(this.value)">
                  </div>
                  
                  <div class="form-group">
                    <label>æ’®å½±è·é›¢ (m)</label>
                    <input type="number" id="distance" value="${selectedPin.distance || state.distance}" 
                           step="0.5" onchange="updateDistance(this.value)">
                  </div>
                  
                  <div class="gsd-display">
                    <strong>GSD:</strong> <span id="gsdValue">${calcGSD(selectedPin.distance || state.distance)}</span> mm/px
                  </div>
                  
                  <div class="form-group">
                    <label>åˆ¤å®š</label>
                    <select id="judgment" class="judgment-${selectedPin.judgment || 'unanalyzed'}"
                            onchange="updateJudgment(this.value)">
                      <option value="" ${!selectedPin.judgment ? 'selected' : ''}>æœªåˆ¤å®š</option>
                      <option value="healthy" ${selectedPin.judgment === 'healthy' ? 'selected' : ''}>å¥å…¨éƒ¨</option>
                      <option value="observe" ${selectedPin.judgment === 'observe' ? 'selected' : ''}>è¦³å¯Ÿ</option>
                      <option value="floating" ${selectedPin.judgment === 'floating' ? 'selected' : ''}>æµ®ãã®å¯èƒ½æ€§ã‚ã‚Š</option>
                    </select>
                  </div>
                  
                  <div class="form-group">
                    <label>åˆ¤å®šãƒ•ãƒ­ãƒ¼</label>
                    <select id="judgmentFlow" onchange="updateJudgmentFlow(this.value)">
                      <option value="flow1" ${selectedPin.judgmentFlow === 'flow1' ? 'selected' : ''}>ç¬¬ä¸€æ¡ä»¶ï¼šçµ±è¨ˆå€¤ãƒ™ãƒ¼ã‚¹ï¼ˆÏƒåŸºæº–ï¼‰</option>
                      <option value="flow2" ${(selectedPin.judgmentFlow === 'flow2' || !selectedPin.judgmentFlow) ? 'selected' : ''}>ç¬¬äºŒæ¡ä»¶ï¼šå±€æ‰€ãƒ¬ãƒ³ã‚¸æ–¹å¼ï¼ˆMax-Minï¼‰</option>
                      <option value="flow3" ${selectedPin.judgmentFlow === 'flow3' ? 'selected' : ''}>ç¬¬ä¸‰æ¡ä»¶ï¼šè©¦é¨“ä½“åŸºæº–ï¼ˆå‚è€ƒï¼‰</option>
                    </select>
                  </div>
                  
                  <div class="form-group">
                    <label>è§£æã‚³ãƒ¡ãƒ³ãƒˆ</label>
                    <textarea id="comment" placeholder="è§£æçµæœã‚’å…¥åŠ›..."
                              onchange="updateComment(this.value)">${selectedPin.comment || ''}</textarea>
                  </div>
                  
                  <div class="form-group">
                    <label>è¿½åŠ ã‚³ãƒ¡ãƒ³ãƒˆ</label>
                    <textarea id="additionalComment" placeholder="è¿½åŠ ã®æ‰€è¦‹ãŒã‚ã‚Œã°..."
                              onchange="updateAdditionalComment(this.value)">${selectedPin.additionalComment || ''}</textarea>
                  </div>
                  
                  <button class="btn btn-primary" style="width:100%; margin-bottom:10px;" 
                          onclick="generateComment()">
                    âœ¨ ã‚³ãƒ¡ãƒ³ãƒˆè‡ªå‹•ç”Ÿæˆ
                  </button>
                  
                  <button class="btn btn-export" onclick="exportReport()">
                    ğŸ“„ ãƒ¬ãƒãƒ¼ãƒˆã‚’å‡ºåŠ›
                  </button>
                  
                  <div class="btn-group">
                    <button class="btn btn-danger" onclick="deletePin()">ğŸ—‘ï¸ ãƒ”ãƒ³å‰Šé™¤</button>
                  </div>
                </div>
              </div>
            </div>
          ` : ''}
        </div>
      `;
    }

    // GSDè¨ˆç®—
    function calcGSD(distance) {
      const fovH = 24;
      const resH = 480;
      const W = 2 * distance * Math.tan((fovH / 2) * Math.PI / 180);
      return (W / resH * 1000).toFixed(1);
    }

    // åˆæœŸãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿
    async function loadData() {
      try {
        const drawingsSnapshot = await db.collection('drawings').get();
        state.drawings = drawingsSnapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        }));

        if (state.drawings.length > 0) {
          state.currentDrawingId = state.drawings[0].id;
          await loadPins(state.drawings[0].id);
        }
      } catch (error) {
        console.error('ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
      }
      state.loading = false;
      render();
    }

    // ãƒ”ãƒ³èª­ã¿è¾¼ã¿
    async function loadPins(drawingId) {
      try {
        const pinsSnapshot = await db.collection('pins')
          .where('drawingId', '==', drawingId)
          .get();
        state.pins = pinsSnapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        }));
      } catch (error) {
        console.error('ãƒ”ãƒ³èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
      }
    }

    // å›³é¢åˆ‡ã‚Šæ›¿ãˆ
    async function switchDrawing(drawingId) {
      state.currentDrawingId = drawingId;
      state.selectedPinId = null;
      await loadPins(drawingId);
      render();
    }

    // å›³é¢è¿½åŠ 
    async function addDrawing() {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'image/*';
      input.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        state.loading = true;
        render();

        try {
          const filename = `${Date.now()}_${file.name}`;
          const ref = storage.ref().child(`drawings/${filename}`);
          await ref.put(file);
          const url = await ref.getDownloadURL();

          const docRef = await db.collection('drawings').add({
            name: file.name,
            url: url,
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
          });

          state.drawings.push({ id: docRef.id, name: file.name, url: url });
          state.currentDrawingId = docRef.id;
        } catch (error) {
          console.error('å›³é¢è¿½åŠ ã‚¨ãƒ©ãƒ¼:', error);
          alert('å›³é¢ã®è¿½åŠ ã«å¤±æ•—ã—ã¾ã—ãŸ');
        }

        state.loading = false;
        render();
      };
      input.click();
    }

    // å›³é¢å‰Šé™¤
    async function deleteDrawing(drawingId) {
      if (!confirm('ã“ã®å›³é¢ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿé–¢é€£ã™ã‚‹ãƒ”ãƒ³ã‚‚å‰Šé™¤ã•ã‚Œã¾ã™ã€‚')) return;

      state.loading = true;
      render();

      try {
        const pinsSnapshot = await db.collection('pins')
          .where('drawingId', '==', drawingId)
          .get();
        
        for (const doc of pinsSnapshot.docs) {
          await db.collection('pins').doc(doc.id).delete();
        }

        await db.collection('drawings').doc(drawingId).delete();

        state.drawings = state.drawings.filter(d => d.id !== drawingId);
        state.pins = state.pins.filter(p => p.drawingId !== drawingId);
        
        if (state.currentDrawingId === drawingId) {
          state.currentDrawingId = state.drawings.length > 0 ? state.drawings[0].id : null;
          state.selectedPinId = null;
          if (state.currentDrawingId) {
            await loadPins(state.currentDrawingId);
          }
        }
      } catch (error) {
        console.error('å›³é¢å‰Šé™¤ã‚¨ãƒ©ãƒ¼:', error);
        alert('å›³é¢ã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ');
      }

      state.loading = false;
      render();
    }

    // å›³é¢ã‚¯ãƒªãƒƒã‚¯ï¼ˆãƒ”ãƒ³è¿½åŠ ï¼‰
    async function handleDrawingClick(e) {
      const wrapper = document.getElementById('drawingWrapper');
      if (!wrapper || !state.currentDrawingId) return;
      
      // ç·¨é›†ãƒ¢ãƒ¼ãƒ‰æ™‚ã¯ãƒ”ãƒ³è¿½åŠ ã—ãªã„
      if (state.editMode) return;
      
      // ãƒ”ãƒ³ã‚¯ãƒªãƒƒã‚¯ã¯é™¤å¤–
      if (e.target.closest('.pin')) return;

      const rect = wrapper.getBoundingClientRect();
      const x = ((e.clientX - rect.left) / rect.width) * 100;
      const y = ((e.clientY - rect.top) / rect.height) * 100;

      try {
        const newPin = {
          drawingId: state.currentDrawingId,
          x: x,
          y: y,
          images: {},
          judgment: null,
          judgmentFlow: 'flow2',
          comment: '',
          additionalComment: '',
          distance: state.distance,
          createdAt: firebase.firestore.FieldValue.serverTimestamp()
        };

        const docRef = await db.collection('pins').add(newPin);
        state.pins.push({ id: docRef.id, ...newPin });
        state.selectedPinId = docRef.id;
        state.activeTab = 'analysis';
        render();
      } catch (error) {
        console.error('ãƒ”ãƒ³è¿½åŠ ã‚¨ãƒ©ãƒ¼:', error);
      }
    }

    // ãƒ”ãƒ³é¸æŠ
    function selectPin(pinId) {
      state.selectedPinId = pinId;
      render();
    }

    // ãƒ‘ãƒãƒ«ã‚’é–‰ã˜ã‚‹
    function closePanel() {
      state.selectedPinId = null;
      render();
    }

    // ã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆ
    function setTab(tab) {
      state.activeTab = tab;
      render();
    }

    // ç”»åƒã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
    async function uploadImage(type, file) {
      if (!file || !state.selectedPinId) return;

      const pin = state.pins.find(p => p.id === state.selectedPinId);
      if (!pin) return;

      try {
        const filename = `${Date.now()}_${file.name}`;
        const ref = storage.ref().child(`pins/${state.selectedPinId}/${type}/${filename}`);
        await ref.put(file);
        const url = await ref.getDownloadURL();

        await db.collection('pins').doc(state.selectedPinId).update({
          [`images.${type}`]: { url: url, filename: file.name }
        });

        pin.images = pin.images || {};
        pin.images[type] = { url: url, filename: file.name };
        
        render();
        alert('ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å®Œäº†');
      } catch (error) {
        console.error('ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼:', error);
        alert('ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¾ã—ãŸ');
      }
    }

    // è¤‡æ•°ç”»åƒè‡ªå‹•æŒ¯ã‚Šåˆ†ã‘ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
    async function uploadMultipleImages(files) {
      if (!files || files.length === 0 || !state.selectedPinId) return;

      const pin = state.pins.find(p => p.id === state.selectedPinId);
      if (!pin) return;

      let uploadCount = 0;
      pin.images = pin.images || {};

      try {
        for (const file of files) {
          const fileName = file.name.toUpperCase();
          let type = null;

          // ãƒ•ã‚¡ã‚¤ãƒ«åã‹ã‚‰è‡ªå‹•åˆ¤å®š
          if (fileName.includes('(8)') || fileName.includes('_8')) {
            type = 'color8';
          } else if (fileName.includes('VB')) {
            type = 'visible';
          } else if (fileName.includes('IR')) {
            type = 'infrared';
          }

          if (!type) {
            console.log(`ãƒ•ã‚¡ã‚¤ãƒ« ${file.name} ã¯åˆ¤å®šã§ãã¾ã›ã‚“ã§ã—ãŸ`);
            continue;
          }

          const filename = `${Date.now()}_${file.name}`;
          const ref = storage.ref().child(`pins/${state.selectedPinId}/${type}/${filename}`);
          await ref.put(file);
          const url = await ref.getDownloadURL();

          await db.collection('pins').doc(state.selectedPinId).update({
            [`images.${type}`]: { url: url, filename: file.name }
          });

          pin.images[type] = { url: url, filename: file.name };
          uploadCount++;
        }

        render();
        if (uploadCount > 0) {
          alert(`${uploadCount}æšã®ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸ`);
        } else {
          alert('ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã§ãã‚‹ç”»åƒãŒã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚\nãƒ•ã‚¡ã‚¤ãƒ«åã«VBã€IRã€(8)ãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
        }
      } catch (error) {
        console.error('ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼:', error);
        alert('ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¾ã—ãŸ');
      }
    }

    // ãƒ”ãƒ³åæ›´æ–°
    async function updatePinName(value) {
      if (!state.selectedPinId) return;
      const pin = state.pins.find(p => p.id === state.selectedPinId);
      if (pin) {
        pin.name = value;
        await db.collection('pins').doc(state.selectedPinId).update({ name: value });
      }
    }

    // æ’®å½±è·é›¢æ›´æ–°
    async function updateDistance(value) {
      if (!state.selectedPinId) return;
      const distance = parseFloat(value) || 8;
      state.distance = distance;
      const pin = state.pins.find(p => p.id === state.selectedPinId);
      if (pin) {
        pin.distance = distance;
        await db.collection('pins').doc(state.selectedPinId).update({ distance: distance });
        document.getElementById('gsdValue').textContent = calcGSD(distance);
      }
    }

    // åˆ¤å®šæ›´æ–°
    async function updateJudgment(value) {
      if (!state.selectedPinId) return;
      const pin = state.pins.find(p => p.id === state.selectedPinId);
      if (pin) {
        pin.judgment = value || null;
        await db.collection('pins').doc(state.selectedPinId).update({ judgment: value || null });
        render();
      }
    }

    // åˆ¤å®šãƒ•ãƒ­ãƒ¼æ›´æ–°
    async function updateJudgmentFlow(value) {
      if (!state.selectedPinId) return;
      const pin = state.pins.find(p => p.id === state.selectedPinId);
      if (pin) {
        pin.judgmentFlow = value;
        await db.collection('pins').doc(state.selectedPinId).update({ judgmentFlow: value });
      }
    }

    // ã‚³ãƒ¡ãƒ³ãƒˆæ›´æ–°
    async function updateComment(value) {
      if (!state.selectedPinId) return;
      const pin = state.pins.find(p => p.id === state.selectedPinId);
      if (pin) {
        pin.comment = value;
        await db.collection('pins').doc(state.selectedPinId).update({ comment: value });
      }
    }

    // è¿½åŠ ã‚³ãƒ¡ãƒ³ãƒˆæ›´æ–°
    async function updateAdditionalComment(value) {
      if (!state.selectedPinId) return;
      const pin = state.pins.find(p => p.id === state.selectedPinId);
      if (pin) {
        pin.additionalComment = value;
        await db.collection('pins').doc(state.selectedPinId).update({ additionalComment: value });
      }
    }

    // ã‚³ãƒ¡ãƒ³ãƒˆè‡ªå‹•ç”Ÿæˆ
    function generateComment() {
      const pin = state.pins.find(p => p.id === state.selectedPinId);
      if (!pin) return;

      const judgment = pin.judgment || '';
      const flow = pin.judgmentFlow || 'flow2';

      const flowTexts = {
        flow1: 'ç¬¬ä¸€æ¡ä»¶ï¼ˆçµ±è¨ˆå€¤ãƒ™ãƒ¼ã‚¹ï¼šÏƒåŸºæº–ï¼‰ã‚’é©ç”¨ã€‚',
        flow2: 'ç¬¬äºŒæ¡ä»¶ï¼ˆå±€æ‰€ãƒ¬ãƒ³ã‚¸æ–¹å¼ï¼šMax-Minï¼‰ã‚’é©ç”¨ã€‚',
        flow3: 'ç¬¬ä¸‰æ¡ä»¶ï¼ˆè©¦é¨“ä½“åŸºæº–ï¼‰ã‚’å‚è€ƒã¨ã—ã¦é©ç”¨ã€‚'
      };

      const templates = {
        healthy: {
          flow1: `${flowTexts.flow1}\nå¥å…¨éƒ¨ã®æ¸©åº¦ã°ã‚‰ã¤ãï¼ˆÏƒï¼‰ã«å¯¾ã—ã€2Ïƒã‚’è¶…ãˆã‚‹æ¸©åº¦å·®ã¯èªã‚ã‚‰ã‚Œãªã„ã€‚æµ®ããƒ»å‰¥é›¢ã‚’ç¤ºã™å±€æ‰€çš„ãªæ¸©åº¦ç•°å¸¸ï¼ˆæ˜ç­ãªå¢ƒç•Œã‚’æŒã¤ä¸­å¿ƒãƒ”ãƒ¼ã‚¯ï¼‰ã¯ç¢ºèªã•ã‚Œãªã„ã€‚\n\nçµè«–ï¼šå¥å…¨ã¨åˆ¤æ–­ã™ã‚‹ã€‚`,
          flow2: `${flowTexts.flow2}\nå¯¾è±¡é ˜åŸŸã®Max-Minã‚’ãƒ•ãƒ«ãƒ¬ãƒ³ã‚¸ã¨ã—ã¦è§£æã€‚8éšèª¿è¡¨ç¤ºã«ãŠã„ã¦2ç›®ç››ã‚Šä»¥ä¸Šã®æ¸©åº¦å·®ã‚’ç¤ºã™ç•°å¸¸éƒ¨ã¯èªã‚ã‚‰ã‚Œãªã„ã€‚\n\nçµè«–ï¼šå¥å…¨ã¨åˆ¤æ–­ã™ã‚‹ã€‚`,
          flow3: `${flowTexts.flow3}\nè©¦é¨“ä½“ã®æ¸©åº¦ãƒ¬ãƒ³ã‚¸ã¨æ¯”è¼ƒã—ã€æµ®ãã‚’ç¤ºã™æ¸©åº¦å·®ã¯ç¢ºèªã•ã‚Œãªã„ã€‚\n\nçµè«–ï¼šå¥å…¨ã¨åˆ¤æ–­ã™ã‚‹ã€‚`
        },
        observe: {
          flow1: `${flowTexts.flow1}\nÎ”T=â—‹â„ƒç¨‹åº¦ã®æ¸©åº¦å·®ã‚’ç¢ºèªã€‚2Ïƒã«è¿‘ã„å€¤ã‚’ç¤ºã™ãŒã€å¢ƒç•ŒãŒã‚„ã‚„ä¸æ˜ç­ã§ã‚ã‚Šã€æµ®ãã¨æ–­å®šã§ããªã„ã€‚\n\nçµè«–ï¼šçµŒéè¦³å¯Ÿã‚’æ¨å¥¨ã™ã‚‹ã€‚`,
          flow2: `${flowTexts.flow2}\nå¯¾è±¡é ˜åŸŸã®Max-Minã‚’ãƒ•ãƒ«ãƒ¬ãƒ³ã‚¸ã¨ã—ã¦è§£æã€‚8éšèª¿è¡¨ç¤ºã«ãŠã„ã¦2ç›®ç››ã‚Šç¨‹åº¦ã®æ¸©åº¦å·®ã‚’ç¢ºèªã™ã‚‹ãŒã€å¢ƒç•ŒãŒä¸æ˜ç­ã€‚\n\nçµè«–ï¼šçµŒéè¦³å¯Ÿã‚’æ¨å¥¨ã™ã‚‹ã€‚`,
          flow3: `${flowTexts.flow3}\nè©¦é¨“ä½“ã®æ¸©åº¦ãƒ¬ãƒ³ã‚¸ã¨æ¯”è¼ƒã—ã€ã‚„ã‚„æ¸©åº¦å·®ãŒèªã‚ã‚‰ã‚Œã‚‹ãŒæ˜ç¢ºãªåˆ¤å®šã«ã¯è‡³ã‚‰ãªã„ã€‚\n\nçµè«–ï¼šçµŒéè¦³å¯Ÿã‚’æ¨å¥¨ã™ã‚‹ã€‚`
        },
        floating: {
          flow1: `${flowTexts.flow1}\nÎ”T=â—‹â„ƒã®é«˜æ¸©éƒ¨ã‚’ç¢ºèªã€‚å¥å…¨éƒ¨ã®Ïƒã«å¯¾ã—2Ïƒä»¥ä¸Šã®æ¸©åº¦å·®ãŒã‚ã‚Šã€å‘¨å›²ã¨ã®æ¸©åº¦å¢ƒç•ŒãŒæ˜ç­ã§ã‚ã‚‹ã€‚\n\nçµè«–ï¼šæµ®ãã®å¯èƒ½æ€§ã‚ã‚Šã¨åˆ¤æ–­ã™ã‚‹ã€‚`,
          flow2: `${flowTexts.flow2}\nå¯¾è±¡é ˜åŸŸã®Max-Minã‚’ãƒ•ãƒ«ãƒ¬ãƒ³ã‚¸ã¨ã—ã¦è§£æã€‚8éšèª¿è¡¨ç¤ºã«ãŠã„ã¦2ç›®ç››ã‚Šä»¥ä¸Šã®æ˜ç­ãªæ¸©åº¦å·®ã‚’ç¢ºèªã€‚å¢ƒç•ŒãŒæ˜ç­ã§ã‚ã‚Šã€æµ®ãã®ç‰¹å¾´ã‚’ç¤ºã™ã€‚\n\nçµè«–ï¼šæµ®ãã®å¯èƒ½æ€§ã‚ã‚Šã¨åˆ¤æ–­ã™ã‚‹ã€‚`,
          flow3: `${flowTexts.flow3}\nè©¦é¨“ä½“ã®æ¸©åº¦ãƒ¬ãƒ³ã‚¸ã¨æ¯”è¼ƒã—ã€æµ®ãã‚’ç¤ºã™æ¸©åº¦å·®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ç¢ºèªã€‚\n\nçµè«–ï¼šæµ®ãã®å¯èƒ½æ€§ã‚ã‚Šã¨åˆ¤æ–­ã™ã‚‹ã€‚`
        }
      };

      let comment = '';
      if (judgment && templates[judgment]) {
        comment = templates[judgment][flow] || '';
      } else {
        comment = 'åˆ¤å®šã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚';
      }

      pin.comment = comment;
      db.collection('pins').doc(state.selectedPinId).update({ comment: comment });
      render();
    }

    // ãƒ”ãƒ³å‰Šé™¤
    async function deletePin() {
      if (!state.selectedPinId || !confirm('ã“ã®ãƒ”ãƒ³ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) return;

      try {
        await db.collection('pins').doc(state.selectedPinId).delete();
        state.pins = state.pins.filter(p => p.id !== state.selectedPinId);
        state.selectedPinId = null;
        render();
      } catch (error) {
        console.error('ãƒ”ãƒ³å‰Šé™¤ã‚¨ãƒ©ãƒ¼:', error);
      }
    }

    // ãƒ”ãƒ³ã‚¯ãƒªãƒƒã‚¯/ç§»å‹•é–‹å§‹
    function handlePinMouseDown(e, pinId) {
      e.stopPropagation();
      if (state.editMode) {
        // ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ = ãƒ‰ãƒ©ãƒƒã‚°ã§ç§»å‹•
        e.preventDefault();
        state.draggingPin = pinId;
      } else {
        // é€šå¸¸ãƒ¢ãƒ¼ãƒ‰ = è©³ç´°è¡¨ç¤º
        selectPin(pinId);
      }
    }
    
    // ç·¨é›†ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ
    function toggleEditMode() {
      state.editMode = !state.editMode;
      state.draggingPin = null;
      render();
    }

    // IRç¯„å›²æç”»ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ
    function toggleDrawingArea() {
      state.isDrawingArea = !state.isDrawingArea;
      if (!state.isDrawingArea) {
        state.tempArea = null;
      }
      render();
    }

    // ç¯„å›²æç”»é–‹å§‹ï¼ˆãƒã‚¦ã‚¹ï¼‰
    function handleAreaMouseDown(e) {
      if (!state.isDrawingArea) return;
      
      const img = document.getElementById('visibleImage');
      if (!img) return;
      
      e.preventDefault();
      const rect = img.getBoundingClientRect();
      const x = ((e.clientX - rect.left) / rect.width) * 100;
      const y = ((e.clientY - rect.top) / rect.height) * 100;
      
      state.tempArea = { startX: x, startY: y, endX: x, endY: y };
      render();
    }

    // ç¯„å›²æç”»ä¸­ï¼ˆãƒã‚¦ã‚¹ï¼‰
    function handleAreaMouseMove(e) {
      if (!state.isDrawingArea || !state.tempArea) return;
      
      const img = document.getElementById('visibleImage');
      if (!img) return;
      
      e.preventDefault();
      const rect = img.getBoundingClientRect();
      const x = ((e.clientX - rect.left) / rect.width) * 100;
      const y = ((e.clientY - rect.top) / rect.height) * 100;
      
      state.tempArea.endX = x;
      state.tempArea.endY = y;
      render();
    }

    // ç¯„å›²æç”»çµ‚äº†
    async function handleAreaMouseUp(e) {
      if (!state.isDrawingArea || !state.tempArea) return;
      
      const pin = state.pins.find(p => p.id === state.selectedPinId);
      if (!pin) return;
      
      // ç¯„å›²ã‚’ç¢ºå®šã—ã¦ä¿å­˜
      pin.thermalArea = { ...state.tempArea };
      
      try {
        await db.collection('pins').doc(state.selectedPinId).update({
          thermalArea: pin.thermalArea
        });
      } catch (error) {
        console.error('ç¯„å›²ä¿å­˜ã‚¨ãƒ©ãƒ¼:', error);
      }
      
      state.tempArea = null;
      state.isDrawingArea = false;
      render();
    }

    // ç¯„å›²æç”»é–‹å§‹ï¼ˆã‚¿ãƒƒãƒï¼‰
    function handleAreaTouchStart(e) {
      if (!state.isDrawingArea) return;
      
      const img = document.getElementById('visibleImage');
      if (!img) return;
      
      e.preventDefault();
      const touch = e.touches[0];
      const rect = img.getBoundingClientRect();
      const x = ((touch.clientX - rect.left) / rect.width) * 100;
      const y = ((touch.clientY - rect.top) / rect.height) * 100;
      
      state.tempArea = { startX: x, startY: y, endX: x, endY: y };
      render();
    }

    // ç¯„å›²æç”»ä¸­ï¼ˆã‚¿ãƒƒãƒï¼‰
    function handleAreaTouchMove(e) {
      if (!state.isDrawingArea || !state.tempArea) return;
      
      const img = document.getElementById('visibleImage');
      if (!img) return;
      
      e.preventDefault();
      const touch = e.touches[0];
      const rect = img.getBoundingClientRect();
      const x = ((touch.clientX - rect.left) / rect.width) * 100;
      const y = ((touch.clientY - rect.top) / rect.height) * 100;
      
      state.tempArea.endX = x;
      state.tempArea.endY = y;
      render();
    }

    // ç¯„å›²å‰Šé™¤
    async function deleteThermalArea() {
      if (!state.selectedPinId || !confirm('IRç¯„å›²ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) return;
      
      const pin = state.pins.find(p => p.id === state.selectedPinId);
      if (!pin) return;
      
      pin.thermalArea = null;
      
      try {
        await db.collection('pins').doc(state.selectedPinId).update({
          thermalArea: null
        });
      } catch (error) {
        console.error('ç¯„å›²å‰Šé™¤ã‚¨ãƒ©ãƒ¼:', error);
      }
      
      render();
    }

    // ãƒ”ãƒ³ãƒ‰ãƒ©ãƒƒã‚°ä¸­
    function handlePinDrag(e) {
      if (!state.draggingPin) return;
      
      const wrapper = document.getElementById('drawingWrapper');
      if (!wrapper) return;
      
      const rect = wrapper.getBoundingClientRect();
      const x = ((e.clientX - rect.left) / rect.width) * 100;
      const y = ((e.clientY - rect.top) / rect.height) * 100;
      
      const pin = state.pins.find(p => p.id === state.draggingPin);
      if (pin) {
        pin.x = Math.max(0, Math.min(100, x));
        pin.y = Math.max(0, Math.min(100, y));
        render();
      }
    }

    // ã‚¿ãƒƒãƒé–‹å§‹
    function handlePinTouchStart(e, pinId) {
      e.stopPropagation();
      if (state.editMode) {
        e.preventDefault();
        state.draggingPin = pinId;
      } else {
        selectPin(pinId);
      }
    }

    // ã‚¿ãƒƒãƒãƒ‰ãƒ©ãƒƒã‚°
    function handleTouchDrag(e) {
      if (!state.draggingPin) return;
      e.preventDefault();
      
      const touch = e.touches[0];
      const wrapper = document.getElementById('drawingWrapper');
      if (!wrapper) return;
      
      const rect = wrapper.getBoundingClientRect();
      const x = ((touch.clientX - rect.left) / rect.width) * 100;
      const y = ((touch.clientY - rect.top) / rect.height) * 100;
      
      const pin = state.pins.find(p => p.id === state.draggingPin);
      if (pin) {
        pin.x = Math.max(0, Math.min(100, x));
        pin.y = Math.max(0, Math.min(100, y));
        render();
      }
    }

    // ãƒ”ãƒ³ç§»å‹•çµ‚äº†
    async function handlePinDragEnd(e) {
      if (!state.draggingPin) return;
      
      const pin = state.pins.find(p => p.id === state.draggingPin);
      if (pin) {
        try {
          await db.collection('pins').doc(state.draggingPin).update({
            x: pin.x,
            y: pin.y
          });
        } catch (error) {
          console.error('ãƒ”ãƒ³ç§»å‹•ä¿å­˜ã‚¨ãƒ©ãƒ¼:', error);
        }
      }
      
      state.draggingPin = null;
    }

    // ãƒ¬ãƒãƒ¼ãƒˆå‡ºåŠ›ï¼ˆä»®ï¼‰
    function exportReport() {
      const pin = state.pins.find(p => p.id === state.selectedPinId);
      if (!pin) return;

      alert(`ãƒ¬ãƒãƒ¼ãƒˆå‡ºåŠ›æ©Ÿèƒ½ã¯æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—ã§å®Ÿè£…ã—ã¾ã™ã€‚\n\nãƒ”ãƒ³: ${pin.name || 'No Name'}\nåˆ¤å®š: ${pin.judgment || 'æœªåˆ¤å®š'}`);
    }

    // åˆæœŸåŒ–
    loadData();
    
    // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«é–¢æ•°ã‚’å…¬é–‹ï¼ˆHTMLã®onclickã‹ã‚‰å‘¼ã¹ã‚‹ã‚ˆã†ã«ï¼‰
    window.switchDrawing = switchDrawing;
    window.addDrawing = addDrawing;
    window.deleteDrawing = deleteDrawing;
    window.handleDrawingClick = handleDrawingClick;
    window.selectPin = selectPin;
    window.closePanel = closePanel;
    window.setTab = setTab;
    window.uploadImage = uploadImage;
    window.uploadMultipleImages = uploadMultipleImages;
    window.updatePinName = updatePinName;
    window.updateDistance = updateDistance;
    window.updateJudgment = updateJudgment;
    window.updateJudgmentFlow = updateJudgmentFlow;
    window.updateComment = updateComment;
    window.updateAdditionalComment = updateAdditionalComment;
    window.generateComment = generateComment;
    window.deletePin = deletePin;
    window.exportReport = exportReport;
    window.toggleEditMode = toggleEditMode;
    window.toggleDrawingArea = toggleDrawingArea;
    window.handleAreaMouseDown = handleAreaMouseDown;
    window.handleAreaMouseMove = handleAreaMouseMove;
    window.handleAreaMouseUp = handleAreaMouseUp;
    window.handleAreaTouchStart = handleAreaTouchStart;
    window.handleAreaTouchMove = handleAreaTouchMove;
    window.deleteThermalArea = deleteThermalArea;
    window.handlePinMouseDown = handlePinMouseDown;
    window.handlePinDrag = handlePinDrag;
    window.handlePinDragEnd = handlePinDragEnd;
    window.handlePinTouchStart = handlePinTouchStart;
    window.handleTouchDrag = handleTouchDrag;
    }); // waitForFirebase end
  </script>
</body>
</html>
